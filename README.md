# Algorithm Design and Analysis

Welcome to the Algorithm Design and Analysis repository, a centralized archive where I document my journey through the multifaceted world of algorithms. This repository serves not only as a storage for code but also as a reflective medium where I analyze and deduce the intricacies of different algorithmic approaches.

---

## Repository Structure

This repository is organized into various folders, each representing a unique exploration or project within the realm of algorithm design and analysis. From classic sorting mechanisms to advanced algorithm implementations and beyond, the repository is an ongoing chronicle of my academic and personal ventures into this essential discipline of computer science.

### Folders:

- **Sorting Algorithms**: Contains code and detailed analysis for a variety of sorting algorithms, performance metrics, and statistical evaluations based on film ratings datasets.

- **Dijkstra's Algorithm: Adjacency List vs Adjacency Matrix Implementations**: Explores the implementation of Dijkstra's Algorithm using different graph representations. Includes performance analysis and comparisons between adjacency lists and adjacency matrices.

- **Tic-Tac-Toe Game with Minimax AI**: Development of a Tic-Tac-Toe game featuring an AI opponent implemented using the Minimax algorithm with alpha-beta pruning. The project includes a graphical user interface using SFML.

---

## Philosophy

The field of algorithms is a cornerstone of efficient problem-solving in software engineering. By examining algorithms beyond their theoretical underpinnings, we can uncover practical insights that drive optimization and innovation. Each project within this repository is an embodiment of that philosophy, presenting not just the 'how' but also the 'why' behind each algorithm's design and its performance in practical scenarios.

---

## Projects

Each project folder is a compendium of related files including:

- **Source Code**: Written in Python/C++, the code samples illustrate the algorithmâ€™s implementation and are accompanied by comments explaining each step of the process.

- **Reports**: Reflective analyses in PDF format detail the experiments conducted, the results obtained, and their significance, providing a narrative that connects theoretical concepts with real-world applications.

---

### Project Summaries

#### **Sorting Algorithms**

Contains implementations of various sorting algorithms such as Quick Sort, Merge Sort, Heap Sort, and Bubble Sort. The project includes performance metrics and statistical evaluations based on datasets like film ratings. Detailed analysis of time complexities and optimization techniques are provided.

#### **Dijkstra's Algorithm: Adjacency List vs Adjacency Matrix Implementations**

This project focuses on the implementation and analysis of **Dijkstra's Algorithm** using two different graph representations:

- **Adjacency List Graph**: Efficient for sparse graphs, where each vertex maintains a list of its adjacent vertices and edge weights.

- **Adjacency Matrix Graph**: Suitable for dense graphs, represented using a 2D matrix indicating edge weights between vertices.

Experiments were conducted to compare the performance of both implementations on graphs of varying sizes and densities. The analysis provides insights into the practical implications of choosing one representation over the other in terms of execution time and memory usage.

#### **Tic-Tac-Toe Game with Minimax AI**

In this project, we developed a **Tic-Tac-Toe game** featuring an AI opponent implemented using the **Minimax algorithm** with alpha-beta pruning. Key features include:

- **Artificial Intelligence**: The AI makes optimal moves by evaluating possible game states, providing a challenging opponent.

- **Graphical User Interface**: Built using **SFML**, offering an interactive and visually engaging experience.

- **Customizable Gameplay**: Supports different board sizes and win conditions, allowing for varied levels of difficulty.

The project explores the application of game theory and AI algorithms in game development, highlighting the balance between computational efficiency and gameplay experience.




